<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ClickHouse查询MergeTree存储引擎数据存储以表hits_v1 为例，它的数据目录如下所示。 123456789101112131415161718192021222324252627282930313233343536.├── 197506_32_85_11│   ├── checksums.txt│   ├── columns.txt│   ├── count.txt│   ├─">
<meta property="og:type" content="article">
<meta property="og:title" content="fgump的博客">
<meta property="og:url" content="http://example.com/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/index.html">
<meta property="og:site_name" content="fgump的博客">
<meta property="og:description" content="ClickHouse查询MergeTree存储引擎数据存储以表hits_v1 为例，它的数据目录如下所示。 123456789101112131415161718192021222324252627282930313233343536.├── 197506_32_85_11│   ├── checksums.txt│   ├── columns.txt│   ├── count.txt│   ├─">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/select.png">
<meta property="og:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/buildquery.png">
<meta property="og:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/step.png">
<meta property="og:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/gap.png">
<meta property="og:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/readRow.png">
<meta property="article:published_time" content="2022-05-10T11:29:28.265Z">
<meta property="article:modified_time" content="2022-05-10T11:29:28.266Z">
<meta property="article:author" content="fgump">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/select.png">

<link rel="canonical" href="http://example.com/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | fgump的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fgump的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fgump">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgump的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 19:29:28" itemprop="dateCreated datePublished" datetime="2022-05-10T19:29:28+08:00">2022-05-10</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/05/10/ClickHouse_查询/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="ClickHouse查询"><a href="#ClickHouse查询" class="headerlink" title="ClickHouse查询"></a>ClickHouse查询</h3><h3 id="MergeTree存储引擎"><a href="#MergeTree存储引擎" class="headerlink" title="MergeTree存储引擎"></a>MergeTree存储引擎</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>以表hits_v1 为例，它的数据目录如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 197506_32_85_11</span><br><span class="line">│   ├── checksums.txt</span><br><span class="line">│   ├── columns.txt</span><br><span class="line">│   ├── count.txt</span><br><span class="line">│   ├── data.bin</span><br><span class="line">│   ├── data.mrk3</span><br><span class="line">│   ├── default_compression_codec.txt</span><br><span class="line">│   ├── minmax_EventDate.idx</span><br><span class="line">│   ├── partition.dat</span><br><span class="line">│   └── primary.idx</span><br><span class="line">├── 201403_1_31_2</span><br><span class="line">│   ├── AdvEngineID.bin</span><br><span class="line">│   ├── AdvEngineID.mrk2</span><br><span class="line">│   ├── Age.bin</span><br><span class="line">│   ├── Age.mrk2</span><br><span class="line">│   ├── BrowserCountry.bin</span><br><span class="line">│   ├── BrowserCountry.mrk2</span><br><span class="line">│   ├── BrowserLanguage.bin</span><br><span class="line">│   ├── BrowserLanguage.mrk2</span><br><span class="line">... ...</span><br><span class="line">│   ├── minmax_EventDate.idx</span><br><span class="line">... ...</span><br><span class="line">├── 202204_109_109_0</span><br><span class="line">│   ├── checksums.txt</span><br><span class="line">│   ├── columns.txt</span><br><span class="line">│   ├── count.txt</span><br><span class="line">│   ├── data.bin</span><br><span class="line">│   ├── data.mrk3</span><br><span class="line">│   ├── default_compression_codec.txt</span><br><span class="line">│   ├── minmax_EventDate.idx</span><br><span class="line">│   ├── partition.dat</span><br><span class="line">│   └── primary.idx</span><br><span class="line">├── detached</span><br><span class="line">├── format_version.txt</span><br><span class="line">└── temp.text</span><br></pre></td></tr></table></figure>
<p>可以看到，上面显示了3个Datapart,DataPart197506_32_85_11和202204_109_109_0的数据组织方式是Compact,而201403_1_31_2的数拒组织方式是Wide。两种方式主要区别在于Compact方式的所有列数据存放在一个Data.bin文件中,而Wide方式中则是每一个列有一个columnsName.bin文件对应。<br>visits_v1: ClickHouse的每个表都会在其设置的数据目录下有个目录文件对应。</p>
<p>197506_32_85_11,201403_1_6_1,202204_109_109_0：分区目录，hits_v1的分区键为StartDate字段的年月(PARTITION BY toYYYYMM(StartDate))</p>
<p>分区目录的格式为partionKey_minBlock_maxBlock_level。level表示的是合并的次数。每个形如partionKey_minBlock_maxBlock_level的目录下的所有文件构成一个DataPart。每个datapart大小有个上限，并不能一直合并。</p>
<p>primary.idx：主键索引文件，用于存放稀疏索引的数据。通过查询条件与稀疏索引能够快速的过滤无用的数据，减少需要加载的数据量。</p>
<p>{column}.bin：列数据的存储文件，以列名+bin为文件名，默认设置采用 lz4 压缩格式。Wide模式下每一列都会有单独的文件。(还有compact模式，所有的列数据文件合并成一个data.bin)</p>
<p>{column}.mrk2：列数据的标记信息，记录了数据块在 bin 文件中的偏移量。标记文件首先与列数据的存储文件对齐，记录了某个压缩块在 bin 文件中的相对位置；其次与索引文件对齐，记录了稀疏索引对应数据在列存储文件中的位置.(compact模式下只有一个data.mrk3文件)</p>
<p>minmax_EventDate.idx: 分区键的minmax索引文件。<br>columns.txt：列名以及数据类型</p>
<p>count.txt：记录数据的总行数。<br><strong>注意</strong>:可能会有读者有疑惑，mark存在的意义在哪，为什么不可以直接通过primary.idx直接索引到.bin数据文件。笔者认为，为了加快数据的查询效率，ClickHouse中的primary索引是常驻内存的，因此需要尽量较少主键索引的大小，而如果没有mark文件，那么势必主键索引中需要记录目前mark文件中有关.bin文件的偏移信息，会造成内存压力。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>具体的以官方文档为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全部数据  :     [-------------------------------------------------------------------------]</span><br><span class="line">CounterID:      [aaaaaaaaaaaaaaaaaabbbbcdeeeeeeeeeeeeefgggggggghhhhhhhhhiiiiiiiiikllllllll]</span><br><span class="line">Date:           [1111111222222233331233211111222222333211111112122222223111112223311122333]</span><br><span class="line">标记:            |      |      |      |      |      |      |      |      |      |      |</span><br><span class="line">                a,1    a,2    a,3    b,3    e,2    e,3    g,1    h,2    i,1    i,3    l,3</span><br><span class="line">标记号:          0      1      2      3      4      5      6      7      8      9      10</span><br></pre></td></tr></table></figure>
<p>如果指定查询如下：</p>
<ol>
<li>CounterID in (‘a’, ‘h’)，服务器会读取标记号在 [0, 3) 和 [6, 8) 区间中的数据。</li>
<li>CounterID IN (‘a’, ‘h’) AND Date &#x3D; 3，服务器会读取标记号在 [1, 3) 和 [7, 8) 区间中的数据。</li>
<li>Date &#x3D; 3，服务器会读取标记号在 [1, 10] 区间中的数据。</li>
</ol>
<p>主键索引与mark文件的生成<br>简单的解释就是：ClickHouse 会根据 index_granularity 的设置将数据分成多个 granule，每个 granule 中索引列的第一个记录将作为索引写入到 primary.idx；其他非索引列也会用相同的策略生成一条 mark 数据写入相应的*.mrk2 文件中，并与主键索引一一对应，并记录该条索引对应的记录列在column中的偏移(偏移是个抽象的概念，具体的.bin数据文件需要压缩存放，而压缩存放有具体为的一系列的数据块，可以理解为(块号:块内偏移)这个放到后序ClickHouse插入数据的文章中详细讲解)</p>
<h4 id="跳数索引"><a href="#跳数索引" class="headerlink" title="跳数索引"></a>跳数索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX index_name expr TYPE type(...) GRANULARITY granularity_value</span><br></pre></td></tr></table></figure>
<p>跳数索引可以理解为索引的索引。将mark文件中每隔granularity_value个值，进行索引。<br>可用的索引类型</p>
<ol>
<li>有minmax 存储指定表达式的极值</li>
<li>set(max_rows) 存储指定表达式的不重复值</li>
<li>ngrambf_v1(n, size_of_bloom_filter_in_bytes, number_of_hash_functions, random_seed)存储一个包含数据块中所有 n元短语（ngram） 的 布隆过滤器</li>
<li>tokenbf_v1(size_of_bloom_filter_in_bytes, number_of_hash_functions, random_seed)跟 ngrambf_v1 类似，但是存储的是token而不是ngrams</li>
<li>bloom_filter(bloom_filter([false_positive]) – 为指定的列存储布隆过滤器</li>
</ol>
<h3 id="SELECT读数据"><a href="#SELECT读数据" class="headerlink" title="SELECT读数据"></a>SELECT读数据</h3><p>SELECT读数据主要分为两三部分，如下图所示。</p>
<ol>
<li>首先通过分区和一系列索引来排除不需要扫描的datapart和Mark(getAnalysisResult)</li>
<li>将待扫描的DataPart划分为更细粒度的ThreadTask，并尽量将不同的磁盘负载分配到不同的线程中去以达到磁盘最大的并行化。(spreadMarkRangesAmongStreams)。</li>
<li>PIPELINE执行时，真正的调度线程拉取markRage(getTask)并从文件中读取数据(readRows)</li>
</ol>
<p><img src="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/select.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder &amp; pipeline, const BuildQueryPipelineSettings &amp;)</span><br><span class="line">&#123;</span><br><span class="line">  auto result = getAnalysisResult();</span><br><span class="line">  if (select.final())</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    else if ((settings.optimize_read_in_order || settings.optimize_aggregation_in_order) &amp;&amp; input_order_info)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    else  </span><br><span class="line">    &#123;</span><br><span class="line">        pipe = spreadMarkRangesAmongStreams(</span><br><span class="line">            std::move(result.parts_with_ranges),</span><br><span class="line">            column_names_to_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析需要扫描的mark"><a href="#分析需要扫描的mark" class="headerlink" title="分析需要扫描的mark"></a>分析需要扫描的mark</h4><p>上一篇文章《ClickHouse的QueryPlan到Pipeline的翻译》中讲述了ClickHouse是如何从queryPlan转化为pipeline，而读数据的第一部分就是在构建pipeline时候做的(IsourceStep.updatePipeline)，调用栈如下。</p>
<p><img src="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/buildquery.png"><br>下面主要详细讲解几个核心函数</p>
<p>getAnalysisResult-&gt;selectRangestoRead()。selectRangestoRead中会分别调用<br>MergeTreeDataSelectExecutor::filterPartsByVirtualColumns()；<br>virtualColumn的官网定义如下，一般情况下我们不会使用到它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Virtual column is an integral table engine attribute that is defined in the engine source code.</span><br><span class="line"></span><br><span class="line">You shouldn’t specify virtual columns in the CREATE TABLE query and you can’t see them in SHOW CREATE TABLE and DESCRIBE TABLE query results. Virtual columns are also read-only, so you can’t insert data into virtual columns.</span><br><span class="line"></span><br><span class="line">To select data from a virtual column, you must specify its name in the SELECT query. SELECT * does not return values from virtual columns.</span><br><span class="line"></span><br><span class="line">If you create a table with a column that has the same name as one of the table virtual columns, the virtual column becomes inaccessible. We do not recommend doing this. To help avoid conflicts, virtual column names are usually prefixed with an underscore.</span><br></pre></td></tr></table></figure>
<p>virtual columns的常用值如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_part  -- name of a part</span><br><span class="line">_part_index -- sequential index of the part in the query result</span><br><span class="line">_partition_id -- name of a partition</span><br><span class="line">_part_uuid -- unique part identifier, if enabled `MergeTree` setting `assign_part_uuids` (Part movement between shards)</span><br><span class="line">_partition_value -- values (tuple) of a `partition by` expression</span><br><span class="line">_sample_factor -- sample_factor from the query</span><br></pre></td></tr></table></figure>

<p>MergeTreeDataSelectExecutor::filterPartsByPartition()，会调用selectPartstoRead.<br>其中(1)处的part_values是filterPartsByVirtualColumns方法返回的结果，因此在遍历每一个part判断他的partition key是否满足要求之前，可以通过其名字是否在part_values中来筛选一下。代码(2)处是真正来判断该datapart的partion key是否满足要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void MergeTreeDataSelectExecutor::selectPartsToRead(</span><br><span class="line">    MergeTreeData::DataPartsVector &amp; parts,</span><br><span class="line">    const std::optional&lt;std::unordered_set&lt;String&gt;&gt; &amp; part_values,</span><br><span class="line">    const std::optional&lt;KeyCondition&gt; &amp; minmax_idx_condition,</span><br><span class="line">    const DataTypes &amp; minmax_columns_types,</span><br><span class="line">    std::optional&lt;PartitionPruner&gt; &amp; partition_pruner,</span><br><span class="line">    const PartitionIdToMaxBlock * max_block_numbers_to_read,</span><br><span class="line">    PartFilterCounters &amp; counters)</span><br><span class="line">&#123;</span><br><span class="line">    MergeTreeData::DataPartsVector prev_parts;</span><br><span class="line">    std::swap(prev_parts, parts);</span><br><span class="line">    for (const auto &amp; part_or_projection : prev_parts)</span><br><span class="line">    &#123;</span><br><span class="line">        const auto * part = part_or_projection-&gt;isProjectionPart() ? part_or_projection-&gt;getParentPart() : part_or_projection.get();</span><br><span class="line">        if (part_values &amp;&amp; part_values-&gt;find(part-&gt;name) == part_values-&gt;end())     //(1)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (partition_pruner)</span><br><span class="line">        &#123;</span><br><span class="line">            if (partition_pruner-&gt;canBePruned(*part)) //(2)</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        parts.push_back(part_or_projection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes()</p>
<p>filterPartsByPrimaryKeyAndSkipIndexes方法整体上并不复杂，大部门代码是方法process_part的函数体(1)处。然后在(4)处创新一个新的线程池，并在(5)处向线程池中提交任务，也就是说会有num_threads个线程会执行process_part方法。</p>
<p>具体来看process_part方法。(2)处markRangesFromPKRange方法是通过主键筛选，(3)处的<br>useful_indices是跳数索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">RangesInDataParts MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(</span><br><span class="line">    MergeTreeData::DataPartsVector &amp;&amp; parts,</span><br><span class="line">    StorageMetadataPtr metadata_snapshot,</span><br><span class="line">    const SelectQueryInfo &amp; query_info,</span><br><span class="line">    const ContextPtr &amp; context,</span><br><span class="line">    const KeyCondition &amp; key_condition,</span><br><span class="line">    const MergeTreeReaderSettings &amp; reader_settings,</span><br><span class="line">    Poco::Logger * log,</span><br><span class="line">    size_t num_streams,</span><br><span class="line">    ReadFromMergeTree::IndexStats &amp; index_stats,</span><br><span class="line">    bool use_skip_indexes)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    /// Let&#x27;s find what range to read from each part.</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        auto process_part = [&amp;](size_t part_index)                    //(1)函数定义 process_part</span><br><span class="line">        &#123;</span><br><span class="line">            auto &amp; part = parts[part_index];</span><br><span class="line"></span><br><span class="line">            RangesInDataPart ranges(part, part_index);</span><br><span class="line"></span><br><span class="line">            size_t total_marks_count = part-&gt;index_granularity.getMarksCountWithoutFinal();</span><br><span class="line"></span><br><span class="line">            if (metadata_snapshot-&gt;hasPrimaryKey())</span><br><span class="line">                ranges.ranges = markRangesFromPKRange(part, metadata_snapshot, key_condition, settings, log); //(2)</span><br><span class="line">            else if (total_marks_count)</span><br><span class="line">                ranges.ranges = MarkRanges&#123;MarkRange&#123;0, total_marks_count&#125;&#125;;</span><br><span class="line"></span><br><span class="line">            sum_marks_pk.fetch_add(ranges.getMarksCount(), std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (auto &amp; index_and_condition : useful_indices)    //(3)</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            parts_with_ranges[part_index] = std::move(ranges);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; //函数结束</span><br><span class="line"></span><br><span class="line">        size_t num_threads = std::min(size_t(num_streams), parts.size());</span><br><span class="line"></span><br><span class="line">        if (num_threads &lt;= 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            /// Parallel loading of data parts.</span><br><span class="line">            ThreadPool pool(num_threads);                           //(4)</span><br><span class="line"></span><br><span class="line">            for (size_t part_index = 0; part_index &lt; parts.size(); ++part_index)</span><br><span class="line">                pool.scheduleOrThrowOnError([&amp;, part_index, thread_group = CurrentThread::getGroup()] //(5)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (thread_group)</span><br><span class="line">                        CurrentThread::attachToIfDetached(thread_group);</span><br><span class="line"></span><br><span class="line">                    process_part(part_index);                       //(6)</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            pool.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return parts_with_ranges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体来看markRangesFromPKRange方法,(1)处方法定义了判断一个MarkRange里是否可能含有满足条件的数据，可能则返回真，否则返回false。(2)处代码，首先将整个datapart的mark放入栈中，然后来判断全部的markRange有没有可能含有目标列。如果没有则直接排除掉(3)。如果可能含有目标列，那么继续将markRange划分，range范围包括step个mark，并将这些新range放入栈中。依次类推。示意图如下</p>
<p><img src="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/step.png"></p>
<p>(4)处代码表示，最后筛选后的结果range都是一个mark，这个时候要判断，该目标mark与上一个符合要求的range之间的gap，如果gap小于参数min_marks_for_seek则，则将这个mark与上一个range合成一个range。示意图如下。</p>
<p><img src="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/gap.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">MarkRanges MergeTreeDataSelectExecutor::markRangesFromPKRange(</span><br><span class="line">    const MergeTreeData::DataPartPtr &amp; part,</span><br><span class="line">    const StorageMetadataPtr &amp; metadata_snapshot,</span><br><span class="line">    const KeyCondition &amp; key_condition,</span><br><span class="line">    const Settings &amp; settings,</span><br><span class="line">    Poco::Logger * log)</span><br><span class="line">&#123;</span><br><span class="line">    MarkRanges res;</span><br><span class="line">    ....</span><br><span class="line">    auto may_be_true_in_range = [&amp;](MarkRange &amp; range)                  //(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (range.end == marks_count &amp;&amp; !has_final_mark)</span><br><span class="line">        &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; used_key_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                create_field_ref(range.begin, i, index_left[i]);</span><br><span class="line">                index_right[i] = POSITIVE_INFINITY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (has_final_mark &amp;&amp; range.end == marks_count)</span><br><span class="line">                range.end -= 1; /// Remove final empty mark. It&#x27;s useful only for primary key condition.</span><br><span class="line"></span><br><span class="line">            for (size_t i = 0; i &lt; used_key_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                create_field_ref(range.begin, i, index_left[i]);</span><br><span class="line">                create_field_ref(range.end, i, index_right[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return key_condition.mayBeTrueInRange(</span><br><span class="line">            used_key_size, index_left.data(), index_right.data(), primary_key.data_types);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (!key_condition.matchesExactContinuousRange())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;MarkRange&gt; ranges_stack = &#123; &#123;0, marks_count&#125; &#125;;</span><br><span class="line">        size_t steps = 0;</span><br><span class="line"></span><br><span class="line">        while (!ranges_stack.empty())                                  //(2)</span><br><span class="line">        &#123;</span><br><span class="line">            MarkRange range = ranges_stack.back();</span><br><span class="line">            ranges_stack.pop_back();</span><br><span class="line"></span><br><span class="line">            if (!may_be_true_in_range(range))                          //(3)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            if (range.end == range.begin + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                /// We saw a useful gap between neighboring marks. Either add it to the last range, or start a new range.</span><br><span class="line">                if (res.empty() || range.begin - res.back().end &gt; min_marks_for_seek)                                   //(4)</span><br><span class="line">                    res.push_back(range);</span><br><span class="line">                else</span><br><span class="line">                    res.back().end = range.end;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                /// Break the segment and put the result on the stack from right to left.</span><br><span class="line">                size_t step = (range.end - range.begin - 1) / settings.merge_tree_coarse_index_granularity + 1;</span><br><span class="line">                size_t end;</span><br><span class="line"></span><br><span class="line">                for (end = range.end; end &gt; range.begin + step; end -= step)</span><br><span class="line">                    ranges_stack.emplace_back(end - step, end);</span><br><span class="line"></span><br><span class="line">                ranges_stack.emplace_back(range.begin, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="划分ThreadTask"><a href="#划分ThreadTask" class="headerlink" title="划分ThreadTask"></a>划分ThreadTask</h4><p>spreadMarkRangesAmongStreams函数中主要通过构建多个MergeTreeThreadSelectProcessor并与同一个MergeTreeReadPool相关联。而MergeTreeReadPool的构造函数中会调用fillPerPartInfo和fillPerThreadInfo方法。fillPerPartInfo方法主要是统计了每个待读取的DataPart的相关信息，比如每个DataPart含有的总mark数。而fillPerThreadInfo方法中则是首先将所有的DataPart按照所在的disk名字进行排序，然后将这些的DataPart，进一步分成小的markranges。Mark作为ClickHouse中读取数据的最小单位，markrange记录了Datapart<br>中mark的范围[begin,end).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">void MergeTreeReadPool::fillPerThreadInfo(</span><br><span class="line">    size_t threads, size_t sum_marks, std::vector&lt;size_t&gt; per_part_sum_marks,</span><br><span class="line">    const RangesInDataParts &amp; parts, size_t min_marks_for_concurrent_read)</span><br><span class="line">&#123;</span><br><span class="line">    threads_tasks.resize(threads);      //thread_taks类似于一个二维数组，存放每个线程tasks</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    using PartsInfo = std::vector&lt;PartInfo&gt;;</span><br><span class="line">    std::queue&lt;PartsInfo&gt; parts_queue;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        // 根据DataPart所在Disk的名字排序</span><br><span class="line">        std::map&lt;String, std::vector&lt;PartInfo&gt;&gt; parts_per_disk;</span><br><span class="line"></span><br><span class="line">        for (size_t i = 0; i &lt; parts.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            PartInfo part_info&#123;parts[i], per_part_sum_marks[i], i&#125;;</span><br><span class="line">            if (parts[i].data_part-&gt;isStoredOnDisk())</span><br><span class="line">                parts_per_disk[parts[i].data_part-&gt;volume-&gt;getDisk()-&gt;getName()].push_back(std::move(part_info));</span><br><span class="line">            else</span><br><span class="line">                parts_per_disk[&quot;&quot;].push_back(std::move(part_info));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (auto &amp; info : parts_per_disk)</span><br><span class="line">            parts_queue.push(std::move(info.second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const size_t min_marks_per_thread = (sum_marks - 1) / threads + 1;</span><br><span class="line"></span><br><span class="line">    // 遍历每一个线程，为每一个线程分配任务</span><br><span class="line">    for (size_t i = 0; i &lt; threads &amp;&amp; !parts_queue.empty(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        auto need_marks = min_marks_per_thread;</span><br><span class="line"></span><br><span class="line">        while (need_marks &gt; 0 &amp;&amp; !parts_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            auto &amp; current_parts = parts_queue.front();</span><br><span class="line">            RangesInDataPart &amp; part = current_parts.back().part;</span><br><span class="line">            size_t &amp; marks_in_part = current_parts.back().sum_marks;</span><br><span class="line">            const auto part_idx = current_parts.back().part_idx;</span><br><span class="line"></span><br><span class="line">            /// Do not get too few rows from part.</span><br><span class="line">            if (marks_in_part &gt;= min_marks_for_concurrent_read &amp;&amp;</span><br><span class="line">                need_marks &lt; min_marks_for_concurrent_read)</span><br><span class="line">                need_marks = min_marks_for_concurrent_read;</span><br><span class="line"></span><br><span class="line">            /// Do not leave too few rows in part for next time.</span><br><span class="line">            if (marks_in_part &gt; need_marks &amp;&amp;</span><br><span class="line">                marks_in_part - need_marks &lt; min_marks_for_concurrent_read)</span><br><span class="line">                need_marks = marks_in_part;</span><br><span class="line"></span><br><span class="line">            MarkRanges ranges_to_get_from_part;</span><br><span class="line">            size_t marks_in_ranges = need_marks;gett</span><br><span class="line"></span><br><span class="line">            /// Get whole part to read if it is small enough.</span><br><span class="line">            if (marks_in_part &lt;= need_marks)</span><br><span class="line">            &#123;</span><br><span class="line">                ranges_to_get_from_part = part.ranges;</span><br><span class="line">                marks_in_ranges = marks_in_part;</span><br><span class="line"></span><br><span class="line">                need_marks -= marks_in_part;</span><br><span class="line">                current_parts.pop_back();</span><br><span class="line">                if (current_parts.empty())</span><br><span class="line">                    parts_queue.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                /// Loop through part ranges.</span><br><span class="line">                while (need_marks &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (part.ranges.empty())</span><br><span class="line">                        throw Exception(&quot;Unexpected end of ranges while spreading marks among threads&quot;, ErrorCodes::LOGICAL_ERROR);</span><br><span class="line"></span><br><span class="line">                    MarkRange &amp; range = part.ranges.front();</span><br><span class="line"></span><br><span class="line">                    const size_t marks_in_range = range.end - range.begin;</span><br><span class="line">                    const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);</span><br><span class="line"></span><br><span class="line">                    ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range);</span><br><span class="line">                    range.begin += marks_to_get_from_range;</span><br><span class="line">                    marks_in_part -= marks_to_get_from_range;</span><br><span class="line">                    need_marks -= marks_to_get_from_range;</span><br><span class="line">                    if (range.begin == range.end)</span><br><span class="line">                        part.ranges.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //</span><br><span class="line">            threads_tasks[i].parts_and_ranges.push_back(&#123; part_idx, ranges_to_get_from_part &#125;);</span><br><span class="line">            threads_tasks[i].sum_marks_in_parts.push_back(marks_in_ranges);</span><br><span class="line">            if (marks_in_ranges != 0)</span><br><span class="line">                remaining_thread_tasks.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //切换到分配下一个线程任务之前，切换disk。这样尽可能的是不同的磁盘负载到不同的线程中去，依次来最大化磁盘并行度。</span><br><span class="line">        if (parts_queue.size() &gt; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            parts_queue.push(std::move(parts_queue.front()));</span><br><span class="line">            parts_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PIPELINE执行"><a href="#PIPELINE执行" class="headerlink" title="PIPELINE执行"></a>PIPELINE执行</h4><p>在pipeline执行的时候，MergeTreeThreadSelectProcessor的work方法会调用到getTask方法向MergeTreeReadPool中请求Task</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">MergeTreeReadTaskPtr MergeTreeReadPool::getTask(size_t min_marks_to_read, size_t thread, const Names &amp; ordered_names)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto thread_idx = thread;</span><br><span class="line">    if (!tasks_remaining_for_this_thread)</span><br><span class="line">    &#123;</span><br><span class="line">      ... //如果本线程的task做完，则尝试窃取其他线程的任务                                                  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    /// Do not leave too little rows in part for next time.</span><br><span class="line">    // 如果此次获取到的range后，剩下的mark比较少，那么就一次行读整个DataPart，提高效率。</span><br><span class="line">    if (marks_in_part &gt; need_marks &amp;&amp;</span><br><span class="line">        marks_in_part - need_marks &lt; min_marks_to_read)</span><br><span class="line">        need_marks = marks_in_part;</span><br><span class="line"></span><br><span class="line">    MarkRanges ranges_to_get_from_part;</span><br><span class="line"></span><br><span class="line">    /// Get whole part to read if it is small enough.</span><br><span class="line">    //DataPart本身含有的mark总数就比较少，也一次性的读取整个DataPart</span><br><span class="line">    if (marks_in_part &lt;= need_marks)</span><br><span class="line">    &#123;</span><br><span class="line">        const auto marks_to_get_from_range = marks_in_part;</span><br><span class="line">        ranges_to_get_from_part = thread_task.ranges;</span><br><span class="line"></span><br><span class="line">        marks_in_part -= marks_to_get_from_range;</span><br><span class="line"></span><br><span class="line">        thread_tasks.parts_and_ranges.pop_back();</span><br><span class="line">        thread_tasks.sum_marks_in_parts.pop_back();</span><br><span class="line"></span><br><span class="line">        if (thread_tasks.sum_marks_in_parts.empty())</span><br><span class="line">            remaining_thread_tasks.erase(thread_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;   </span><br><span class="line"></span><br><span class="line">        /// Loop through part ranges.</span><br><span class="line">        // 遍历这个DataPart的range，找到足够数量的mark然后返回。</span><br><span class="line">        while (need_marks &gt; 0 &amp;&amp; !thread_task.ranges.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            auto &amp; range = thread_task.ranges.front();</span><br><span class="line"></span><br><span class="line">            const size_t marks_in_range = range.end - range.begin;</span><br><span class="line">            const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);</span><br><span class="line"></span><br><span class="line">            ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range);</span><br><span class="line">            range.begin += marks_to_get_from_range;</span><br><span class="line">            if (range.begin == range.end)</span><br><span class="line">                thread_task.ranges.pop_front();</span><br><span class="line"></span><br><span class="line">            marks_in_part -= marks_to_get_from_range;</span><br><span class="line">            need_marks -= marks_to_get_from_range;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return std::make_unique&lt;MergeTreeReadTask&gt;(</span><br><span class="line">        part.data_part, ranges_to_get_from_part, part.part_index_in_query, ordered_names,</span><br><span class="line">        per_part_column_name_set[part_idx], per_part_columns[part_idx], per_part_pre_columns[part_idx],</span><br><span class="line">        prewhere_info &amp;&amp; prewhere_info-&gt;remove_prewhere_column, per_part_should_reorder[part_idx], std::move(curr_task_size_predictor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MergeTreeThreadSelectProcessor的work在执行完getTask方法后，会根据返回的结果去读取数据。<br>代码调用如下。</p>
<p><img src="https://lxhblog.oss-cn-beijing.aliyuncs.com/bigdata/readRow.png"></p>
<p>因为clickHouse有谓词下推的优化，MergeTreeRangeReader::read读取的逻辑上是首先根据PreWhere信息(如果有的话)去读取prewhere列(1)处，然后读取其他需要的列(2)处，最后根据preWhere信息去除掉不满足要求的列(5)处。而其中真正读取数据时(1,2,4)处，会根据DataPart类型对应于MergeTreeReaderCompact、MergeTreeReaderWide以及mergeTreeReaderInMemory三种Reader来最终将数据读到内存。除了mergeTreeReaderInMemory，其他两个读取数据主要涉及编解码，比较底层，有兴趣的同学可以阅读源码MergeTreeReaderWide&#x2F;Compact&#x2F;InMemroy::readRows。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MergeTreeRangeReader::ReadResult MergeTreeRangeReader::read(size_t max_rows, MarkRanges &amp; ranges)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (prev_reader)</span><br><span class="line">    &#123;</span><br><span class="line">        read_result = prev_reader-&gt;read(max_rows, ranges);                  //(1)</span><br><span class="line">        ...</span><br><span class="line">        Columns columns = continueReadingChain(read_result, num_read_rows); //(2)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        for (auto &amp; column : columns)                                       //(3)</span><br><span class="line">            read_result.columns.emplace_back(std::move(column));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        read_result = startReadingChain(max_rows, ranges);                  //(4)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    executePrewhereActionsAndFilterColumns(read_result);                    //(5)</span><br><span class="line">    return read_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/09/ClickHouse_Read/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClickHouse%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.</span> <span class="nav-text">ClickHouse查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MergeTree%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.</span> <span class="nav-text">MergeTree存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">2.1.</span> <span class="nav-text">数据存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.</span> <span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E6%95%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.</span> <span class="nav-text">跳数索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">SELECT读数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E9%9C%80%E8%A6%81%E6%89%AB%E6%8F%8F%E7%9A%84mark"><span class="nav-number">3.1.</span> <span class="nav-text">分析需要扫描的mark</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%92%E5%88%86ThreadTask"><span class="nav-number">3.2.</span> <span class="nav-text">划分ThreadTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PIPELINE%E6%89%A7%E8%A1%8C"><span class="nav-number">3.3.</span> <span class="nav-text">PIPELINE执行</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fgump</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/smartlxh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;smartlxh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/smartlxh@gmail.com" title="E-Mail → smartlxh@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgump</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://fgump.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/";
    this.page.identifier = "2022/05/10/ClickHouse_查询/";
    this.page.title = "";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://fgump.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
