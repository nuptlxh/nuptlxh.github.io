<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ClickHouse中write与mergewrite过程写过程中对应的Processor是MergeTreeSink。继承关系为 1MergeTreeSink-&gt;SinkToStorage-&gt;ExceptionKeepingTransform-&gt;IProcessor 其中主要的方法实现在MergeTreeSink::consume()方法中。consume方法的逻辑首先是(1)">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse中write与merge">
<meta property="og:url" content="http://example.com/2022/06/03/ClickHouse%E4%B8%ADWrite%E4%B8%8EMerge/index.html">
<meta property="og:site_name" content="fgump的博客">
<meta property="og:description" content="ClickHouse中write与mergewrite过程写过程中对应的Processor是MergeTreeSink。继承关系为 1MergeTreeSink-&gt;SinkToStorage-&gt;ExceptionKeepingTransform-&gt;IProcessor 其中主要的方法实现在MergeTreeSink::consume()方法中。consume方法的逻辑首先是(1)">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-03T02:29:40.000Z">
<meta property="article:modified_time" content="2022-06-06T08:38:32.323Z">
<meta property="article:author" content="fgump">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/06/03/ClickHouse%E4%B8%ADWrite%E4%B8%8EMerge/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ClickHouse中write与merge | fgump的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fgump的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/03/ClickHouse%E4%B8%ADWrite%E4%B8%8EMerge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fgump">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgump的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ClickHouse中write与merge
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-03 10:29:40" itemprop="dateCreated datePublished" datetime="2022-06-03T10:29:40+08:00">2022-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-06 16:38:32" itemprop="dateModified" datetime="2022-06-06T16:38:32+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2022/06/03/ClickHouse%E4%B8%ADWrite%E4%B8%8EMerge/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/06/03/ClickHouse中Write与Merge/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="ClickHouse中write与merge"><a href="#ClickHouse中write与merge" class="headerlink" title="ClickHouse中write与merge"></a>ClickHouse中write与merge</h2><h3 id="write过程"><a href="#write过程" class="headerlink" title="write过程"></a>write过程</h3><p>写过程中对应的Processor是MergeTreeSink。<br>继承关系为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MergeTreeSink-&gt;SinkToStorage-&gt;ExceptionKeepingTransform-&gt;IProcessor</span><br></pre></td></tr></table></figure>
<p>其中主要的方法实现在MergeTreeSink::consume()方法中。consume方法的逻辑首先是(1)处将Chunk转化成Block，Block可以看做是Chunk的封装，都是column数据的容器。然后(2)处通过<br>将整个Block的数据按照分区键来分为多个block，每个block中的数据属于同一个partition。<br>(3)处通过遍历每个block，然后在(4)处将每个block的数据写入临时文件，也可以理解为临时DataPart。(5)处将每个分区的DataPart放入容器partitions。然后我们看(6)处的finishDelayedChunk方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void MergeTreeSink::consume(Chunk chunk)</span><br><span class="line">&#123;</span><br><span class="line">    auto block = getHeader().cloneWithColumns(chunk.detachColumns()); //(1)</span><br><span class="line">    ...</span><br><span class="line">    auto part_blocks = storage.writer.splitBlockIntoParts(block,  max_parts_per_block, metadata_snapshot, context);//(2)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    for (auto &amp; current_block : part_blocks)                        //(3)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        auto temp_part = storage.writer.writeTempPart(current_block, metadata_snapshot, context);//(4)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        partitions.emplace_back(MergeTreeSink::DelayedChunk::Partition //(5)</span><br><span class="line">        &#123;</span><br><span class="line">            .temp_part = std::move(temp_part),</span><br><span class="line">            .elapsed_ns = elapsed_ns,</span><br><span class="line">            .block_dedup_token = std::move(block_dedup_token)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finishDelayedChunk();                                           //(6)</span><br><span class="line">    delayed_chunk = std::make_unique&lt;MergeTreeSink::DelayedChunk&gt;();</span><br><span class="line">    delayed_chunk-&gt;partitions = std::move(partitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishDelayedChunk方法主要是将各个临时datapart刷到磁盘，然后使用renameTempPartAndAdd将临时DataPart改为正式的名字，最后触发后台merge操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MergeTreeSink::finishDelayedChunk()</span><br><span class="line">&#123;</span><br><span class="line">    if (!delayed_chunk)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    for (auto &amp; partition : delayed_chunk-&gt;partitions)</span><br><span class="line">    &#123;</span><br><span class="line">        partition.temp_part.finalize();          //(1)</span><br><span class="line"></span><br><span class="line">        auto &amp; part = partition.temp_part.part;</span><br><span class="line"></span><br><span class="line">        /// Part can be deduplicated, so increment counters and add to part log only if it&#x27;s really added</span><br><span class="line">        //(2)</span><br><span class="line">        if (storage.renameTempPartAndAdd(part, context-&gt;getCurrentTransaction().get(), &amp;storage.increment, nullptr, storage.getDeduplicationLog(), partition.block_dedup_token))</span><br><span class="line">        &#123;</span><br><span class="line">            PartLog::addNewPart(storage.getContext(), part, partition.elapsed_ns);</span><br><span class="line"></span><br><span class="line">            /// Initiate async merge - it will be done if it&#x27;s good time for merge and if there are space in &#x27;background_pool&#x27;.</span><br><span class="line">            storage.background_operations_assignee.trigger(); //(3)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delayed_chunk.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h3><p>在介绍merge过程中，首先介绍两个线程池。<br>BackgroundSchedulePool和MergeTreeBackgroundExecutor。因为merge操作是异步的，相关的任务会在个线程池中实现。</p>
<h4 id="BackgroundSchedulePool"><a href="#BackgroundSchedulePool" class="headerlink" title="BackgroundSchedulePool"></a>BackgroundSchedulePool</h4><p>可以看到BackgroundSchedulePoo中的线程为ThreadFromGlobalPool，所以其实任务都是在全局的线程池中执行的。在本系列的第一篇文章中讲过ClickHouse中的全局线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class BackgroundSchedulePool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    using Threads = std::vector&lt;ThreadFromGlobalPool&gt;;</span><br><span class="line"></span><br><span class="line">    void threadFunction();                                //worker函数</span><br><span class="line">    void delayExecutionThreadFunction();</span><br><span class="line"></span><br><span class="line">    Threads threads;                                      //线程队列</span><br><span class="line">    Poco::NotificationQueue queue;                        //任务队列</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BackgroundSchedulePool::threadFunction()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    while (!shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (Poco::AutoPtr&lt;Poco::Notification&gt; notification = queue.waitDequeueNotification(wait_timeout_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            TaskNotification &amp; task_notification = static_cast&lt;TaskNotification &amp;&gt;(*notification);</span><br><span class="line">            task_notification.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="MergeTreeBackgroundExecutor"><a href="#MergeTreeBackgroundExecutor" class="headerlink" title="MergeTreeBackgroundExecutor"></a>MergeTreeBackgroundExecutor</h4><p>MergeTreeBackgroundExecutor有两个任务队列，pending和active,pending表示待执行的tasks，而active表示正在执行的tasks。MergeTreeBackgroundExecutor被实现为coroutine,原注释为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor for a background MergeTree related operations such as merges, mutations, fetches an so on.</span><br><span class="line"> *  It can execute only successors of ExecutableTask interface.</span><br><span class="line"> *  Which is a self-written coroutine. It suspends, when returns true from executeStep() method.</span><br></pre></td></tr></table></figure>
<p>任务队列的实现为类MergeMutateRuntimeQueue，可以理解为一个优先级队列，因为在执行merge的时候，ClickHouse的策略认为应该先merge小DataPart来提高系统性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Queue&gt;</span><br><span class="line">class MergeTreeBackgroundExecutor final : public shared_ptr_helper&lt;MergeTreeBackgroundExecutor&lt;Queue&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    bool trySchedule(ExecutableTaskPtr task);</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    void routine(TaskRuntimeDataPtr item);</span><br><span class="line">    void threadFunction();                                //worker函数       </span><br><span class="line"></span><br><span class="line">    Queue pending&#123;&#125;;                                      //任务队列</span><br><span class="line">    boost::circular_buffer&lt;TaskRuntimeDataPtr&gt; active&#123;0&#125;; //任务队列</span><br><span class="line"></span><br><span class="line">    ThreadPool pool;                                      //线程池</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;class Queue&gt;</span><br><span class="line">void MergeTreeBackgroundExecutor&lt;Queue&gt;::threadFunction()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            routine(std::move(item));  //routine函数中会调用task-&gt;executeStep</span><br><span class="line">        &#125;</span><br><span class="line">        catch (...)</span><br><span class="line">        &#123;</span><br><span class="line">            tryLogCurrentException(__PRETTY_FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h4><p>上面讲到在方法finishDelayedChunk的最后通过调用storage.background_operations_assignee.trigger()触发merge。trigger方法中通过<br>BackgroundSchedulePool::TaskHolder(holder是在BackgroundJobsAssignee::start方法中初始化的)来向BackgroundSchedulePool提交任务。任务函数如下，merge的任务类型为DataProcessing。因此最后一定会有某个线程执行了threadFunc函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void BackgroundJobsAssignee::threadFunc()</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    bool succeed = false;</span><br><span class="line">    switch (type)</span><br><span class="line">    &#123;</span><br><span class="line">        case Type::DataProcessing:</span><br><span class="line">            succeed = data.scheduleDataProcessingJob(*this);</span><br><span class="line">            break;</span><br><span class="line">        case Type::Moving:</span><br><span class="line">            succeed = data.scheduleDataMovingJob(*this);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!succeed)</span><br><span class="line">        postpone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体来看scheduleDataProcessingJob函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool StorageMergeTree::scheduleDataProcessingJob(BackgroundJobsAssignee &amp; assignee) //-V657</span><br><span class="line">&#123;</span><br><span class="line">    if (shutdown_called)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    auto metadata_snapshot = getInMemoryMetadataPtr();</span><br><span class="line">    std::shared_ptr&lt;MergeMutateSelectedEntry&gt; merge_entry, mutate_entry;</span><br><span class="line">    bool were_some_mutations_skipped = false;</span><br><span class="line"></span><br><span class="line">    auto share_lock = lockForShare(RWLockImpl::NO_QUERY, getSettings()-&gt;lock_acquire_timeout_for_background_operations);</span><br><span class="line"></span><br><span class="line">    MergeTreeTransactionHolder transaction_for_merge;</span><br><span class="line">    MergeTreeTransactionPtr txn;</span><br><span class="line">    if (transactions_enabled.load(std::memory_order_relaxed))</span><br><span class="line">    &#123;</span><br><span class="line">        /// TODO Transactions: avoid beginning transaction if there is nothing to merge.</span><br><span class="line">        txn = TransactionLog::instance().beginTransaction();</span><br><span class="line">        transaction_for_merge = MergeTreeTransactionHolder&#123;txn, /* autocommit = */ true&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        merge_entry = selectPartsToMerge(metadata_snapshot, false, &#123;&#125;, false, nullptr, share_lock, lock, txn);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (merge_entry)</span><br><span class="line">    &#123;</span><br><span class="line">        auto task = std::make_shared&lt;MergePlainMergeTreeTask&gt;(*this, metadata_snapshot, false, Names&#123;&#125;, merge_entry, share_lock, common_assignee_trigger);</span><br><span class="line">        task-&gt;setCurrentTransaction(std::move(transaction_for_merge), std::move(txn));</span><br><span class="line">        assignee.scheduleMergeMutateTask(task);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selectPartsToMerge</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MergeMutateSelectedEntry&gt; StorageMergeTree::selectPartsToMerge(</span><br><span class="line">    const StorageMetadataPtr &amp; metadata_snapshot,</span><br><span class="line">    bool aggressive,</span><br><span class="line">    const String &amp; partition_id,</span><br><span class="line">    bool final,</span><br><span class="line">    String * out_disable_reason,</span><br><span class="line">    TableLockHolder &amp; /* table_lock_holder */,</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; &amp; lock,</span><br><span class="line">    const MergeTreeTransactionPtr &amp; txn,</span><br><span class="line">    bool optimize_skip_merged_partitions,</span><br><span class="line">    SelectPartsDecision * select_decision_out)</span><br><span class="line">&#123;</span><br><span class="line">    auto data_settings = getSettings();</span><br><span class="line"></span><br><span class="line">    auto future_part = std::make_shared&lt;FutureMergedMutatedPart&gt;();</span><br><span class="line"></span><br><span class="line">    if (storage_settings.get()-&gt;assign_part_uuids)</span><br><span class="line">        future_part-&gt;uuid = UUIDHelpers::generateV4();</span><br><span class="line"></span><br><span class="line">    auto can_merge = [this, &amp;lock](const DataPartPtr &amp; left, const DataPartPtr &amp; right, const MergeTreeTransaction * tx, String *) -&gt; bool</span><br><span class="line">    &#123;</span><br><span class="line">        if (tx)</span><br><span class="line">        &#123;</span><br><span class="line">            /// Cannot merge parts if some of them are not visible in current snapshot</span><br><span class="line">            /// TODO Transactions: We can use simplified visibility rules (without CSN lookup) here</span><br><span class="line">            if (left &amp;&amp; !left-&gt;version.isVisible(tx-&gt;getSnapshot(), Tx::EmptyTID))</span><br><span class="line">                return false;</span><br><span class="line">            if (right &amp;&amp; !right-&gt;version.isVisible(tx-&gt;getSnapshot(), Tx::EmptyTID))</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            /// Do not try to merge parts that are locked for removal (merge will probably fail)</span><br><span class="line">            if (left &amp;&amp; left-&gt;version.isRemovalTIDLocked())</span><br><span class="line">                return false;</span><br><span class="line">            if (right &amp;&amp; right-&gt;version.isRemovalTIDLocked())</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// This predicate is checked for the first part of each range.</span><br><span class="line">        /// (left = nullptr, right = &quot;first part of partition&quot;)</span><br><span class="line">        if (!left)</span><br><span class="line">            return !currently_merging_mutating_parts.count(right);</span><br><span class="line">        return !currently_merging_mutating_parts.count(left) &amp;&amp; !currently_merging_mutating_parts.count(right)</span><br><span class="line">            &amp;&amp; getCurrentMutationVersion(left, lock) == getCurrentMutationVersion(right, lock) &amp;&amp; partsContainSameProjections(left, right);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SelectPartsDecision select_decision = SelectPartsDecision::CANNOT_SELECT;</span><br><span class="line"></span><br><span class="line">    if (partition_id.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        UInt64 max_source_parts_size = merger_mutator.getMaxSourcePartsSizeForMerge();</span><br><span class="line">        bool merge_with_ttl_allowed = getTotalMergesWithTTLInMergeList() &lt; data_settings-&gt;max_number_of_merges_with_ttl_in_pool;</span><br><span class="line"></span><br><span class="line">        /// TTL requirements is much more strict than for regular merge, so</span><br><span class="line">        /// if regular not possible, than merge with ttl is not also not</span><br><span class="line">        /// possible.</span><br><span class="line">        if (max_source_parts_size &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            select_decision = merger_mutator.selectPartsToMerge(</span><br><span class="line">                future_part,</span><br><span class="line">                aggressive,</span><br><span class="line">                max_source_parts_size,</span><br><span class="line">                can_merge,</span><br><span class="line">                merge_with_ttl_allowed,</span><br><span class="line">                txn,</span><br><span class="line">                out_disable_reason);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (out_disable_reason)</span><br><span class="line">            *out_disable_reason = &quot;Current value of max_source_parts_size is zero&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    merging_tagger = std::make_unique&lt;CurrentlyMergingPartsTagger&gt;(future_part, MergeTreeDataMergerMutator::estimateNeededDiskSpace(future_part-&gt;parts), *this, metadata_snapshot, false);</span><br><span class="line">    return std::make_shared&lt;MergeMutateSelectedEntry&gt;(future_part, std::move(merging_tagger), MutationCommands::create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merger_mutator.selectPartsToMerge为方法，逻辑主要为遍历目前的所以可见的DataPart(事务)，这里需要注意的是，ClickHouse在内存中以索引的形式维护这些DataPart信息，因此这些读出来的DataPart是有序的，排序根据(partition_id, min_block, max_block, level, mutation)。</p>
<p>结合merger_mutator.selectPartsToMerge方法和 can_merge方法总结<br>能够Merge的DataPart需要满足如下条件：</p>
<ol>
<li>首先能够merge的DataPart必须是同一个分区，且是连续的。</li>
<li>使用事务时候，DataPart是同时可见的</li>
<li>待更正的mutation版本是一致的。</li>
</ol>
<p>因为每次可以Merge的DataPart数量是有限制的，因此还需要在所有可以合并的DataPart中选择最合适的Range来合并。实现在如下方法中，是一种启发式算法，有兴趣的同学可以研究一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PartsRange select(</span><br><span class="line">        const PartsRanges &amp; parts_ranges,</span><br><span class="line">        size_t max_total_size_to_merge)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MergeTreeDataMergerMutator::selectPartsToMerge</span><br></pre></td></tr></table></figure>
<p>这里大约概括下选择parts的策略，里面还有很多细节。感兴趣的同学可以去研读代码</p>
<h4 id="merge的执行"><a href="#merge的执行" class="headerlink" title="merge的执行"></a>merge的执行</h4><p>上面说到，在选完待merge的parts后，那么如何把这些part，merge起来呢。构建了一个MergePlainMergeTreeTask，然后通过assignee.scheduleMergeMutateTask方法最终将task加入到MergeTreeBackgroundExecutor的pending队列里。由上述讲过的ergeTreeBackgroundExecutor的执行逻辑，最终会执行MergePlainMergeTreeTask的executeStep，executeStep函数返回true说明还需要再次执行，那么这个任务执行完executeStep后还会放回到penging队列里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">bool MergePlainMergeTreeTask::executeStep()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    switch (state)</span><br><span class="line">    &#123;</span><br><span class="line">        case State::NEED_PREPARE :</span><br><span class="line">        &#123;</span><br><span class="line">            prepare();</span><br><span class="line">            state = State::NEED_EXECUTE;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case State::NEED_EXECUTE :</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                if (merge_task-&gt;execute())</span><br><span class="line">                    return true;</span><br><span class="line"></span><br><span class="line">                state = State::NEED_FINISH;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (...)</span><br><span class="line">            &#123;</span><br><span class="line">                write_part_log(ExecutionStatus::fromCurrentException());</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MergePlainMergeTreeTask::prepare()</span><br><span class="line">&#123;</span><br><span class="line">    future_part = merge_mutate_entry-&gt;future_part;</span><br><span class="line">    stopwatch_ptr = std::make_unique&lt;Stopwatch&gt;();</span><br><span class="line"></span><br><span class="line">    const Settings &amp; settings = storage.getContext()-&gt;getSettingsRef();</span><br><span class="line">    merge_list_entry = storage.getContext()-&gt;getMergeList().insert(</span><br><span class="line">        storage.getStorageID(),</span><br><span class="line">        future_part,</span><br><span class="line">        settings);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    merge_task = storage.merger_mutator.mergePartsToTemporaryPart(</span><br><span class="line">            future_part,</span><br><span class="line">            metadata_snapshot,</span><br><span class="line">            merge_list_entry.get(),</span><br><span class="line">            &#123;&#125; /* projection_merge_list_element */,</span><br><span class="line">            table_lock_holder,</span><br><span class="line">            time(nullptr),</span><br><span class="line">            storage.getContext(),</span><br><span class="line">            merge_mutate_entry-&gt;tagger-&gt;reserved_space,</span><br><span class="line">            deduplicate,</span><br><span class="line">            deduplicate_by_columns,</span><br><span class="line">            storage.merging_params,</span><br><span class="line">            txn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据状态会首先执行prepare，prepare中调用的mergePartsToTemporaryPart方什么都没做，只是构造了一个MergeTask对象并返回。等到下次在执行这个task的时候，根据状态会继续执行mergeTask-&gt;execute方法,也就是会首先执行prepare方法然后执行executeImpl方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using ExecuteAndFinalizeHorizontalPartSubtasks = std::array&lt;std::function&lt;bool()&gt;, 2&gt;;</span><br><span class="line"></span><br><span class="line">        ExecuteAndFinalizeHorizontalPartSubtasks subtasks</span><br><span class="line">        &#123;</span><br><span class="line">            [this] () &#123; return prepare(); &#125;,</span><br><span class="line">            [this] () &#123; return executeImpl(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecuteAndFinalizeHorizontalPartSubtasks::iterator subtasks_iterator = subtasks.begin();</span><br><span class="line"></span><br><span class="line">bool MergeTask::ExecuteAndFinalizeHorizontalPart::execute()</span><br><span class="line">&#123;</span><br><span class="line">    assert(subtasks_iterator != subtasks.end());</span><br><span class="line">    if ((*subtasks_iterator)())</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    /// Move to the next subtask in an array of subtasks</span><br><span class="line">    ++subtasks_iterator;</span><br><span class="line">    return subtasks_iterator != subtasks.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare方法中做了许多检查和准备工作然后写入context中，比如检查新part名字是否重合，磁盘空间是否满足，以及各个DataPar方式等等，最重要的两个方法是chooseMergeAlgorithm以及createMergedStream</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    global_ctx-&gt;chosen_merge_algorithm = chooseMergeAlgorithm();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (global_ctx-&gt;chosen_merge_algorithm)</span><br><span class="line">    &#123;</span><br><span class="line">        case MergeAlgorithm::Horizontal :</span><br><span class="line">        &#123;</span><br><span class="line">            global_ctx-&gt;merging_columns = global_ctx-&gt;storage_columns;</span><br><span class="line">            global_ctx-&gt;merging_column_names = global_ctx-&gt;all_column_names;</span><br><span class="line">            global_ctx-&gt;gathering_columns.clear();</span><br><span class="line">            global_ctx-&gt;gathering_column_names.clear();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MergeAlgorithm::Vertical :</span><br><span class="line">        &#123;</span><br><span class="line">            ctx-&gt;rows_sources_file = createTemporaryFile(ctx-&gt;tmp_disk-&gt;getPath());</span><br><span class="line">            ctx-&gt;rows_sources_uncompressed_write_buf = ctx-&gt;tmp_disk-&gt;writeFile(fileName(ctx-&gt;rows_sources_file-&gt;path()), DBMS_DEFAULT_BUFFER_SIZE, WriteMode::Rewrite, global_ctx-&gt;context-&gt;getWriteSettings());</span><br><span class="line">            ctx-&gt;rows_sources_write_buf = std::make_unique&lt;CompressedWriteBuffer&gt;(*ctx-&gt;rows_sources_uncompressed_write_buf);</span><br><span class="line"></span><br><span class="line">            MergeTreeDataPartInMemory::ColumnToSize local_merged_column_to_size;</span><br><span class="line">            for (const MergeTreeData::DataPartPtr &amp; part : global_ctx-&gt;future_part-&gt;parts)</span><br><span class="line">                part-&gt;accumulateColumnSizes(local_merged_column_to_size);</span><br><span class="line"></span><br><span class="line">            ctx-&gt;column_sizes = ColumnSizeEstimator(</span><br><span class="line">                std::move(local_merged_column_to_size),</span><br><span class="line">                global_ctx-&gt;merging_column_names,</span><br><span class="line">                global_ctx-&gt;gathering_column_names);</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default :</span><br><span class="line">            throw Exception(&quot;Merge algorithm must be chosen&quot;, ErrorCodes::LOGICAL_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    createMergedStream();</span><br><span class="line"></span><br><span class="line">    global_ctx-&gt;to = std::make_shared&lt;MergedBlockOutputStream&gt;(</span><br><span class="line">        global_ctx-&gt;new_data_part,</span><br><span class="line">        global_ctx-&gt;metadata_snapshot,</span><br><span class="line">        global_ctx-&gt;merging_columns,</span><br><span class="line">        MergeTreeIndexFactory::instance().getMany(global_ctx-&gt;metadata_snapshot-&gt;getSecondaryIndices()),</span><br><span class="line">        ctx-&gt;compression_codec,</span><br><span class="line">        global_ctx-&gt;txn,</span><br><span class="line">        /*reset_columns=*/ true,</span><br><span class="line">        ctx-&gt;blocks_are_granules_size,</span><br><span class="line">        global_ctx-&gt;context-&gt;getWriteSettings());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /// This is the end of preparation. Execution will be per block.</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMergedStream其实就是构建一个QueryPipeline，有多少个DataPart就有多少个ISource，然后添加一个mergeTransform。看到PullingPipelineExecutor有没有很熟悉，在本系列的文章&lt;&lt;ClickHouse中Pipeline的执行&gt;&gt;中说过，PullingPipelineExecutor是执行pipeline的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void MergeTask::ExecuteAndFinalizeHorizontalPart::createMergedStream()</span><br><span class="line">&#123;</span><br><span class="line">    /** Read from all parts, merge and write into a new one.</span><br><span class="line">      * In passing, we calculate expression for sorting.</span><br><span class="line">      */</span><br><span class="line">    Pipes pipes;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    for (const auto &amp; part : global_ctx-&gt;future_part-&gt;parts)</span><br><span class="line">    &#123;</span><br><span class="line">        auto input = std::make_unique&lt;MergeTreeSequentialSource&gt;(</span><br><span class="line">            *global_ctx-&gt;data, global_ctx-&gt;storage_snapshot, part, global_ctx-&gt;merging_column_names, ctx-&gt;read_with_direct_io, true);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        //</span><br><span class="line">        if (global_ctx-&gt;metadata_snapshot-&gt;hasSortingKey())</span><br><span class="line">        &#123;</span><br><span class="line">            pipe.addSimpleTransform([this](const Block &amp; header)</span><br><span class="line">            &#123;</span><br><span class="line">                return std::make_shared&lt;ExpressionTransform&gt;(header, global_ctx-&gt;metadata_snapshot-&gt;getSortingKey().expression);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pipes.emplace_back(std::move(pipe));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    //根据存储引擎的不同，选择不同的mergeTransform</span><br><span class="line">    switch (ctx-&gt;merging_params.mode)</span><br><span class="line">    &#123;</span><br><span class="line">        case MergeTreeData::MergingParams::Ordinary:</span><br><span class="line">            merged_transform = std::make_shared&lt;MergingSortedTransform&gt;(</span><br><span class="line">                header, pipes.size(), sort_description, merge_block_size, 0, ctx-&gt;rows_sources_write_buf.get(), true, ctx-&gt;blocks_are_granules_size);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case MergeTreeData::MergingParams::Collapsing:</span><br><span class="line">            merged_transform = std::make_shared&lt;CollapsingSortedTransform&gt;(</span><br><span class="line">                header, pipes.size(), sort_description, ctx-&gt;merging_params.sign_column, false,</span><br><span class="line">                merge_block_size, ctx-&gt;rows_sources_write_buf.get(), ctx-&gt;blocks_are_granules_size);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case MergeTreeData::MergingParams::Summing:</span><br><span class="line">            merged_transform = std::make_shared&lt;SummingSortedTransform&gt;(</span><br><span class="line">                header, pipes.size(), sort_description, ctx-&gt;merging_params.columns_to_sum, partition_key_columns, merge_block_size);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto res_pipe = Pipe::unitePipes(std::move(pipes));</span><br><span class="line">    res_pipe.addTransform(std::move(merged_transform));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    global_ctx-&gt;merged_pipeline = QueryPipeline(std::move(res_pipe));</span><br><span class="line">    global_ctx-&gt;merging_executor = std::make_unique&lt;PullingPipelineExecutor&gt;(global_ctx-&gt;merged_pipeline);                                    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么executeImpl函数就很简单了就是执行QueryPipeline(1)处,之前文章讲过PullingPipelineExecutor-&gt;pull是pipeline执行的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl()</span><br><span class="line">&#123;</span><br><span class="line">    Block block;</span><br><span class="line">    if (!ctx-&gt;is_cancelled() &amp;&amp; (global_ctx-&gt;merging_executor-&gt;pull(block)))  //(1)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整体过程概括来说，执行写入Pipeline时，最终执行的核心方法是在MergeTreeSink类consume方法中，首先将写入的数据按分区分成多个Block，然后针对每个Block形成一个DataPart并写入临时文件，然后刷盘到disk，最后通过改名字使得临时DataPart生效。然后触发后台merge。merge的过程其实大体分为两部分，首先是选择能够merge的Datapart，其次是真正的构建流水线来将不同的DataPart合起来。</p>
<p><strong>注</strong>：整个过程省略了很多细节，只是讲解了大体上的执行过程和逻辑，如果全部展开的话，内容实在是太多了。比方其中涉及到的DataPart事务transaction，选择DataPart的启发式算法以及MergeTransorm的执行。后续会写些文章慢慢补充完善。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ClickHouse/" rel="tag"># ClickHouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/10/ClickHouse_%E6%9F%A5%E8%AF%A2/" rel="prev" title="ClickHouse的ReadPath">
      <i class="fa fa-chevron-left"></i> ClickHouse的ReadPath
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/06/%E6%B5%85%E8%B0%88%E5%AD%98%E7%AE%97%E5%88%86%E7%A6%BB/" rel="next" title="浅谈存算分离">
      浅谈存算分离 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ClickHouse%E4%B8%ADwrite%E4%B8%8Emerge"><span class="nav-number">1.</span> <span class="nav-text">ClickHouse中write与merge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#write%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">write过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">merge过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BackgroundSchedulePool"><span class="nav-number">1.2.1.</span> <span class="nav-text">BackgroundSchedulePool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MergeTreeBackgroundExecutor"><span class="nav-number">1.2.2.</span> <span class="nav-text">MergeTreeBackgroundExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.3.</span> <span class="nav-text">调用关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">1.2.4.</span> <span class="nav-text">merge的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fgump</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/smartlxh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;smartlxh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/smartlxh@gmail.com" title="E-Mail → smartlxh@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/baage" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;baage" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>ZhiHu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgump</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://fgump.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2022/06/03/ClickHouse%E4%B8%ADWrite%E4%B8%8EMerge/";
    this.page.identifier = "2022/06/03/ClickHouse中Write与Merge/";
    this.page.title = "ClickHouse中write与merge";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://fgump.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
